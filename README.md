# paru-cuter

更可爱的paru\
至少最开始是这么想的，还是说说我干了什么和怎么用吧
> 额，先说一下我不会写rust

## 脚本作用

目前所有文本的 "可爱化" 都是由 chatgpt3.5 完成，后续可能会针对某些字符串单独修改，或者在整体风格上用另一种提示词重构\
为了处理这么多文本，我写了几个脚本用来处理和替换字符 (/script):

- string-process.sh: 删除空行/扔掉注释和源字符，筛选出真正需要处理的翻译后的字符串
- exchange.sh: 生成对最终 .po 文件的 sed 替换规则/用处理后的字符替换 .po 中的源字符串

## 实现方式

因为要将文件交给gpt处理，所以这里把源 `.po` 文件的注释与源字符串过滤掉只留下翻译后的字符串，这样能省下将近1/4的行数也没什么特别大的影响\
写入文件(备用)后带上提示词 逐段/全部 交给gpt处理
> 尽量不要处理 help 的信息，对使用者好一点

最终的替换由 sed 和对应的写在文件里的规则实现\
这里创建的规则是由，前后两个精简字符串文件的行数确定的\
源翻译文件的第一行，转换成风格化后文件的第一行
> 所以绝对不能出现行数错误或相同行的意思不符

## 步骤

储存库已经干了这些活了，如果只是想装上试试不需要看这些，直接跳到安装就行\
呐，如果要从头处理的话需要:

### 生成只有关键信息的翻译字符串

```shell
# 生成仅关键信息字符串，并写入一个文件
string-process.sh fetch-key-info xxx.po > ./string-source
```

风格化处理后写入另一个文件像: string-out

如果输出的文件行数和源文件不符或者中间某行的意思错位了，就只能人眼二叉树咯\
不过如果有空行倒是可以用这个:

```shell
string-process.sh remove-blank-line ./string-out
```

> 从gpt复制或多或少都会有点吧

### 配置 exchange.sh 的语言

```shell
#!/bin/bash
...
# 语言
Lang=zh_CN
```

### 生成替换规则 (script/sed-rules)

```shell
exchange.sh make-sed-rules
```

### 打印经过替换后的 .po 文件

```shell
# 打印
exchange.sh exchange
# 或者直接输出到当前目录 (script/xxx.po):
exchange.sh exchange-to-file
```

将写着正确地区码(zh_CN.po)的文件放入 `储存库/po/`

## 安装和恢复脚本

### 安装

运行 `install.sh`

### 脚本会干什么

调用paru生成`.mo`二进制文件的脚本(的复制品)，源`paru:/script/mkmo`\
这回在 储存库根目录 下生成`locale`文件夹，这里面包含了需要被放进 系统目录 的文件

但在那之前，脚本会把`/usr/share/locale`下的所有 `paru.mp` 复制到储存库的`/backup`作为备份，不然的话你也可以重新安装`paru`来恢复啦

最后将`储存库/locale`写入`/usr/share/`，这一步需要 `root` 权限

### 恢复

刚才说到了，安装前会备份所有paru的本地化文件，脚本也能快速的用他们恢复翻译文件

运行 `install.sh restore`

## 碎碎念

- 为什么不 完全fork一个paru呢\
因为`paru储存库`不是`paru软件包`，还要考虑`PKGBUILD`文件的问题，懒得折腾了
- 这可爱吗\
重在学习，可不可爱什么的还是得看提示词嘛，我还是写不出来灵魂，格式对了就行，咕咕
- 哈，你改我pacman管得东西，小心下次更新就给你改过去嗷(凶)\
那就再装一遍嘛，再说你看`v2`和上一个版本之间隔了多久，还有难道你会一直用这种东西吗，工具就是工具，玩归玩，回显看不懂了难受的是自己。
- 这个逻辑是不是能用在所有用`gettext`弄本地化的项目里\
大概率可以吧...
- 为什么不弄pacman，及常用文本量又超大(相对)\
系统软件搞坏了不好折腾，所以就没想这回事

## 许可证

这个储存库虽然和`paru`没什么关系，但翻译文件仍然是`paru`的一部分，所以顺便把整个储存库都加上`GNU v3`的协议了
